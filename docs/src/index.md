# Juqbox.jl Documentation

## Installation
The following instructions assume that you have already installed Julia (currently version 1.5.3) on your system. Before installing Juqbox, we recommend that you add the following line to your .bash_profile (or corresponding file):<br>
**export JULIA_PROJECT="@."**<br>
This environment variable tells Julia to look for Project.toml files in your current or parent directory.

### Building and testing **Juqbox**
shell> julia<br>
julia> ]<br>
(@v1.5) pkg> add  https://github.com/LLNL/Juqbox.jl.git<br>
(@v1.5) pkg> precompile<br>
(@v1.5) pkg> test Juqbox<br>
... all tests should pass ...<br>

To exit the package manager and Julia you do<br>
(@v1.5) pkg> (DEL) <br>
julia> exit()

## Workflow

The work flow for solving a quantum optimal control problem consists of the following general steps:
1. Specify the problem
2. Optimize
3. Visualize the results

### 1. Specifying the problem
The setup phase includes specifying
- The size of the state vector
- The system and control Hamiltonians
- The target gate transformation
- Duration of the gate and number of time steps for integrating Schroedinger's equation.
For the parameterization the control functions, you need to specify
- Carrier wave frequencies
- Number of B-spline coefficients in each spline

The properties of the control problem are stored in a `mutable struct` that is populated by calling
- `params = Juqbox.objparams()`.

The next steps are:
- Assign the initial parameter vector (called `pcof0` in the examples below)
- Set bounds for the parameter vector to be imposed during the optimization
- Allocate working arrays by calling `wa = Juqbox.Working_arrays()`
- Assign convergence criteria and other parameters for the optimizer
- Build the optimization structure by calling `prob = Juqbox.setup_ipopt_problem()`

### 2. Optimization
Once you have been assigned the `params` and `prob` objects, as well as the initial parameter vector 
`pcof0`, the optimizer is invoked by
- `pcof = Juqbox.run_optimizer(prob, pcof0 [, jld2_filename])`

### 3. Visualizing the results
General properties of the optimized solution such as trace infidelity and unitary accuracy can be evaluated, 
and a number of figures can generated by invoking
- `pl = Juqbox.plot_results(params, pcof)`

An array of Julia plot objects is returned in `pl`. These objects can be visualized on the screen
- `display(pl[1])`
where `pl[1]` is the first Julia plot object. The following plot objects are populated by the script: 
- `pl[1]` Evolution of the state vector population
- `pl[2]` Control functions in the rotating frame of reference
- `pl[3]` Population of forbidden energy levels
- `pl[4]` Lab frame control function(s)
- `pl[5]` Fourier transform of the lab-frame control functions (linear scale)
- `pl[6]` Fourier transform of the lab-frame control functions (log scale)
- `pl[7]` Coefficients of the optimized parameter vector
- `pl[8]` Convergence of the optimization

## Examples

Examples of the setup procedure can be found in the scripts in the `Juqbox.jl/examples` directory.
The examples are invoked by, e.g.
- `include("cnot1-setup.jl")`
The following cases are included:
- `rabi-setup.jl` Pi-pulse (X-gate) for a qubit, i.e. a Rabi oscillator.
- `cnot1-setup.jl` CNOT gate for a single qudit with 4 essential and 2 guard levels. 
- `flux-setup.jl` CNOT gate for single qubit with a flux-tuning control Hamiltonian.
- `cnot2-setup.jl` CNOT gate for a pair of coupled qubits with guard levels.
- `cnot3-setup.jl` Cross-resonance CNOT gate for a pair of qubits that are coupled by a cavity resonator.
**Note:** This case reads an optimized solution from file.

## Exported types

The following types are exported and available by `using Juqbox`.
```@autodocs
Modules = [Juqbox]
Order = [:type]
```

## Exported functions

The following methods (functions) are exported and available by `using Juqbox`.
```@autodocs
Modules = [Juqbox]
Order = [:function]
```

## Index
```@index
Modules = [Juqbox]
```





